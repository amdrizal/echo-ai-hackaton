"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __importDefault(require("events"));
const react_native_daily_js_1 = __importDefault(require("@daily-co/react-native-daily-js"));
const apiClient_1 = require("./apiClient");
class VapiEventEmitter extends events_1.default {
    on(event, listener) {
        super.on(event, listener);
        return this;
    }
    once(event, listener) {
        super.once(event, listener);
        return this;
    }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    removeListener(event, listener) {
        super.removeListener(event, listener);
        return this;
    }
    removeAllListeners(event) {
        super.removeAllListeners(event);
        return this;
    }
}
class Vapi extends VapiEventEmitter {
    started = false;
    call = null;
    cameraDeviceValue = null;
    cameraDeviceItems = [];
    audioDeviceValue = null;
    audioDevicesItems = [];
    constructor(apiToken, apiBaseUrl) {
        super();
        apiClient_1.apiClient.baseUrl = apiBaseUrl ?? 'https://api.vapi.ai';
        apiClient_1.apiClient.setSecurityData(apiToken);
    }
    async cleanup() {
        if (!this.call)
            return;
        this.removeEventListeners();
        this.started = false;
        await this.call.destroy();
        this.call = null;
        this.emit('call-end');
    }
    handleRemoteSpeech(e) {
        if (e?.status === 'stopped') {
            this.emit('speech-end');
        }
        else if (e?.status === 'started') {
            this.emit('speech-start');
        }
        else {
            console.log('unhandled remote speech status', e);
        }
    }
    onAppMessage(e) {
        if (!e) {
            return;
        }
        try {
            if (e.data === 'listening') {
                return this.emit('call-start');
            }
            else {
                try {
                    const parsedMessage = JSON.parse(e.data);
                    if (parsedMessage?.type === 'speech-update') {
                        this.handleRemoteSpeech(parsedMessage);
                    }
                    this.emit('message', parsedMessage);
                }
                catch (parseError) {
                    console.log('Error parsing message data: ', parseError);
                }
            }
        }
        catch (e) {
            console.error(e);
        }
    }
    onJoinedMeeting() {
        this.call?.enumerateDevices().then(({ devices }) => {
            this.updateAvailableDevices(devices);
            this.emit('call-start');
        });
    }
    onTrackStarted(e) {
        if (!e ||
            !e.participant ||
            e.participant?.local ||
            e.track.kind !== 'audio' ||
            e?.participant?.user_name !== 'Vapi Speaker') {
            return;
        }
        this.call?.sendAppMessage('playable');
    }
    async refreshSelectedDevice() {
        const devicesInUse = await this.call?.getInputDevices();
        const cameraDevice = devicesInUse?.camera;
        if (devicesInUse && cameraDevice?.deviceId) {
            try {
                this.cameraDeviceValue = cameraDevice.deviceId;
                this.call?.setCamera(this.cameraDeviceValue);
            }
            catch (error) {
                console.error('error setting camera device', error);
            }
        }
        const speakerDevice = devicesInUse?.speaker;
        if (devicesInUse && speakerDevice?.deviceId) {
            try {
                this.audioDeviceValue = speakerDevice.deviceId;
                await this.call?.setAudioDevice(this.audioDeviceValue);
            }
            catch (error) {
                console.error('error setting audio device', error);
            }
        }
    }
    updateAvailableDevices(devices) {
        const inputDevices = devices
            ?.filter((device) => device.kind === 'videoinput')
            .map((device) => {
            return {
                value: device.deviceId,
                label: device.label,
                originalValue: device,
            };
        });
        this.cameraDeviceItems = inputDevices || [];
        const outputDevices = devices
            ?.filter((device) => device.kind === 'audio')
            .map((device) => {
            return {
                value: device.deviceId,
                label: device.label,
                originalValue: device,
            };
        });
        this.audioDevicesItems = outputDevices || [];
        this.refreshSelectedDevice();
    }
    initEventListeners() {
        if (!this.call)
            return;
        this.call.on('available-devices-updated', (e) => {
            this.updateAvailableDevices(e?.availableDevices);
        });
        this.call.on('app-message', (e) => {
            this.onAppMessage(e);
        });
        this.call.on('track-started', (e) => {
            this.onTrackStarted(e);
        });
        this.call.on('participant-left', (e) => {
            this.cleanup();
        });
        this.call.on('left-meeting', (e) => {
            this.cleanup();
        });
        const events = ['joined-meeting', 'left-meeting', 'error'];
        const handleNewMeetingState = async (_event) => {
            switch (this.call?.meetingState()) {
                case 'joined-meeting':
                    return this.onJoinedMeeting();
                case 'left-meeting':
                    return this.cleanup();
                case 'error':
                    await this.cleanup();
                    break;
            }
        };
        handleNewMeetingState();
        for (const event of events) {
            this.call.on(event, handleNewMeetingState);
        }
    }
    removeEventListeners() {
        if (!this.call)
            return;
        const events = [
            'available-devices-updated',
            'app-message',
            'track-started',
            'participant-left',
            'joined-meeting',
            'left-meeting',
            'error',
        ];
        for (const event of events) {
            this.call.off(event, (e) => console.log('Off ', e));
        }
    }
    async start(assistant, assistantOverrides) {
        if (this.started) {
            return null;
        }
        this.started = true;
        const webCall = (await apiClient_1.apiClient.call.callControllerCreateWebCall({
            assistant: typeof assistant === 'string' ? undefined : assistant,
            assistantId: typeof assistant === 'string' ? assistant : undefined,
            assistantOverrides,
        })).data;
        const roomUrl = webCall.webCallUrl;
        if (!roomUrl) {
            throw new Error('webCallUrl is not available');
        }
        try {
            this.call = react_native_daily_js_1.default.createCallObject({
                audioSource: true,
                videoSource: false,
            });
            this.initEventListeners();
            this.call?.join({
                url: roomUrl,
            });
            return webCall;
        }
        catch (e) {
            console.error(e);
            this.emit('error', e);
            this.cleanup();
            return null;
        }
    }
    stop() {
        this.cleanup();
    }
    send(message) {
        this.call?.sendAppMessage(JSON.stringify(message));
    }
    setMuted(mute) {
        try {
            if (!this.call) {
                throw new Error('Call object is not available.');
            }
            this.call.setLocalAudio(!mute);
        }
        catch (error) {
            throw error;
        }
    }
    isMuted() {
        try {
            if (!this.call) {
                return false;
            }
            return this.call.localAudio() === false;
        }
        catch (error) {
            throw error;
        }
    }
}
exports.default = Vapi;
