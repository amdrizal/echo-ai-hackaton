"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DailyMediaView = void 0;
var daily_js_1 = __importDefault(require("@daily-co/daily-js"));
var react_native_webrtc_1 = require("@daily-co/react-native-webrtc");
var DailyMediaView_1 = __importDefault(require("./DailyMediaView"));
exports.DailyMediaView = DailyMediaView_1.default;
var iOSCallObjectBundleCache_1 = __importDefault(require("./iOSCallObjectBundleCache"));
require("react-native-url-polyfill/auto"); // Applies global URL polyfill
var react_native_background_timer_1 = __importDefault(require("react-native-background-timer"));
var base_64_1 = require("base-64");
var react_native_1 = require("react-native");
// Preventing RN issue getrandomvalues not supported
// https://github.com/uuidjs/uuid#getrandomvalues-not-supported
require("react-native-get-random-values");
var DailyNativeUtils = react_native_1.NativeModules.DailyNativeUtils, WebRTCModule = react_native_1.NativeModules.WebRTCModule;
var webRTCEventEmitter = new react_native_1.NativeEventEmitter(WebRTCModule);
var dailyNativeUtilsEventEmitter = new react_native_1.NativeEventEmitter(DailyNativeUtils);
var hasAudioFocus;
var appState;
var audioFocusChangeListeners = new Set();
var appActiveStateChangeListeners = new Set();
var systemScreenCaptureStopListeners = new Set();
var systemScreenCaptureStartCallback;
function setupEventListeners() {
    // audio focus: used by daily-js to auto-mute mic, for instance
    if (react_native_1.Platform.OS === 'android') {
        hasAudioFocus = true; // safe assumption, hopefully
        webRTCEventEmitter.addListener('EventAudioFocusChange', function (event) {
            if (!event || typeof event.hasFocus !== 'boolean') {
                console.error('invalid EventAudioFocusChange event');
            }
            var hadAudioFocus = hasAudioFocus;
            hasAudioFocus = event.hasFocus;
            if (hadAudioFocus !== hasAudioFocus) {
                audioFocusChangeListeners.forEach(function (listener) {
                    return listener(hasAudioFocus);
                });
            }
        });
    }
    // app active state: used by daily-js to auto-mute cam, for instance
    appState = react_native_1.AppState.currentState;
    react_native_1.AppState.addEventListener('change', function (nextState) {
        var previousState = appState;
        appState = nextState;
        var wasActive = previousState === 'active';
        var isActive = appState === 'active';
        if (wasActive !== isActive) {
            appActiveStateChangeListeners.forEach(function (listener) { return listener(isActive); });
        }
    });
    if (react_native_1.Platform.OS === 'ios') {
        // screen capture stop: used to synchronize JS screen sharing state with iOS
        // system screen capture state, which can be controlled outside the app via
        // the control center or by tapping the notification in the corner.
        dailyNativeUtilsEventEmitter.addListener('EventSystemScreenCaptureStop', function () {
            systemScreenCaptureStopListeners.forEach(function (listener) { return listener(); });
        });
        // when we invoke to start the screen share, we first invoke to start the screen capture
        // and add the listener, so we are only going to start the screen share if the capture has started
        // that is why we just need a single callback
        dailyNativeUtilsEventEmitter.addListener('EventSystemScreenCaptureStart', function () {
            if (systemScreenCaptureStartCallback) {
                systemScreenCaptureStartCallback();
            }
        });
    }
}
function setupGlobals() {
    // WebRTC APIs + global `window` object
    (0, react_native_webrtc_1.registerGlobals)();
    // A shim to prevent errors in call machine bundle (not ideal)
    global.window.addEventListener = function () { };
    global.btoa = base_64_1.encode;
    global.atob = base_64_1.decode;
    // A workaround for iOS HTTP cache not caching call object bundle due to size
    if (react_native_1.Platform.OS === 'ios') {
        global.iOSCallObjectBundleCache = iOSCallObjectBundleCache_1.default;
    }
    // Let timers run while Android app is in the background.
    // See https://github.com/jitsi/jitsi-meet/blob/caabdadf19ae5def3f8173acec6c49111f50a04e/react/features/mobile/polyfills/browser.js#L409,
    // where this technique was borrowed from.
    // For now we don't need this for iOS since we're recommending that apps use
    // the "voip" background mode capability, which keeps the app running normally
    // during a call.
    if (react_native_1.Platform.OS === 'android') {
        global.clearTimeout = react_native_background_timer_1.default.clearTimeout.bind(react_native_background_timer_1.default);
        global.clearInterval = react_native_background_timer_1.default.clearInterval.bind(react_native_background_timer_1.default);
        global.setInterval = react_native_background_timer_1.default.setInterval.bind(react_native_background_timer_1.default);
        global.setTimeout = function (fn, ms) {
            if (ms === void 0) { ms = 0; }
            return react_native_background_timer_1.default.setTimeout(fn, ms);
        };
    }
    global.DailyNativeUtils = __assign(__assign({}, DailyNativeUtils), { isIOS: react_native_1.Platform.OS === 'ios', isAndroid: react_native_1.Platform.OS === 'android', setAudioMode: WebRTCModule.setDailyAudioMode, setAudioDevice: WebRTCModule.setAudioDevice, getAudioDevice: WebRTCModule.getAudioDevice, enableNoOpRecordingEnsuringBackgroundContinuity: WebRTCModule.enableNoOpRecordingEnsuringBackgroundContinuity, addAudioFocusChangeListener: function (listener) {
            audioFocusChangeListeners.add(listener);
        }, removeAudioFocusChangeListener: function (listener) {
            audioFocusChangeListeners.delete(listener);
        }, addAppActiveStateChangeListener: function (listener) {
            appActiveStateChangeListeners.add(listener);
        }, removeAppActiveStateChangeListener: function (listener) {
            appActiveStateChangeListeners.delete(listener);
        }, addSystemScreenCaptureStopListener: function (listener) {
            systemScreenCaptureStopListeners.add(listener);
        }, removeSystemScreenCaptureStopListener: function (listener) {
            systemScreenCaptureStopListeners.delete(listener);
        }, setSystemScreenCaptureStartCallback: function (listener) {
            systemScreenCaptureStartCallback = listener;
        }, platform: react_native_1.Platform });
}
setupEventListeners();
setupGlobals();
exports.default = daily_js_1.default;
__exportStar(require("@daily-co/daily-js"), exports);
__exportStar(require("@daily-co/react-native-webrtc"), exports);
